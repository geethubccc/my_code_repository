这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，
这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。
提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，
一共15个1。

输入格式：
输入在一行中给出一个不以5结尾的正奇数x（<1000）。

输出格式：
在一行中输出相应的最小的s和n，其间以1个空格分隔。

输入样例：
31
输出样例：
3584229390681 15

Code(gcc):

/*这里有一个问题就是整数的最大范围
不如就unsigned long; 还要有不止一位
也就是说要有取余再加到后面的动作
0~4294967295（10位） 即 0~（2的32次方-1）
因为x<1000所以最多七位，即前一个的的余数乘以不知道多少位写在最前面。
不不不，不需要，直接检查就好
*/
/*暂时的思路：处理*/
/*不如直接将s=s%x;*/
// #include <stdio.h>
// int main(void)
// {
//     int x,n;
//     unsigned long s;
// //    i=0;
//     n=1;
//     s=1;
//     scanf("%d",&x);
//     while(s%x!=0)
//     {
//         if(s>=1111111111)           //10位
//         {
//             printf("%lu",s/x);
//             s=s%x;
// //            printf("ee");
            
//         }
//         s=s*10+1;
//         n++;
// //        printf("1");                  //输入31输出十四位1（少的一位是最后一位）没问题
//     }
// //     printf("%lu",s/x);
//     if(s<1111111111)
//     {
//         printf("%ld",s/x);
//     }
//     printf(" %d",n);
//     return 0;
// }


#include <stdio.h>
int main(void)
{
    int x,s,n;
    s=1;
    n=1;                    //已经确定x为正整数所以不需要考虑0
    scanf("%d",&x);
    while(s<x)
    {
        s=s*10+1;
        n++;
    }
    while(s%x!=0)                       //(s%x!=0)
    {
         printf("%d",s/x);              //结果是0也要输出啊
//         if(s>=x)
//         {
//             printf("%d",s/x);
//         }
//         else if(s<x)
//         {
//             printf("%d",s/x);
//         }
        s=s%x;
        s=s*10+1;
        n++;
    }
    printf("%d",s/x);
    printf(" %d",n);
    return 0;
}


// #include <stdio.h>
// int main()
// {
// 	int x,bchu=0,cnt=0,s;
// 	scanf("%d",&x);
// 	//确保被除数bchu大于所输入数 
// 	while(bchu<x)
// 	{
// 		bchu=bchu*10+1;
// 		cnt++;
// 	}
// 	// 每除一次，若除不尽，则余数作被除数且加一位1
// 	while(bchu%x!=0) 
// 	{
// 		s=bchu/x;
// //         if(bchu>=x)
// //         {
// 		printf("%d",s);//输出商的一位 
// //         }
// 		bchu=bchu%x;//余数作被除数
// // 		if(bchu==0)
// // 		{
// // 			break;
// // 		 } 
        
// 		 bchu=bchu*10+1;//余数作被除数且加一位1
// 		 cnt++;//统计1的个数 
// 	}
// 		s=bchu/x;
// 	printf("%d",s);//输出商的一位 
// 	printf(" %d",cnt);
// 	return 0;
// }
//https://blog.csdn.net/hlhe_14/article/details/105313288
